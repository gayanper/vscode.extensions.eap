diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests17.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests17.java
index 769d07af8c..68e86bc191 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests17.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests17.java
@@ -27,7 +27,7 @@ public class CompletionTests17 extends AbstractJavaModelCompletionTests {
 	private static int unqualifiedExact_Rel = R_DEFAULT+R_RESOLVED+R_EXACT_EXPECTED_TYPE+ R_CASE+ R_INTERESTING +R_UNQUALIFIED+R_NON_RESTRICTED;
 	private static int keyword_Rel= R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_RESTRICTED;
 	static {
-		 // TESTS_NAMES = new String[]{"test034"};
+//		 TESTS_NAMES = new String[]{"testGH2260_CaseTypePattern"};
 	}
 
 	public CompletionTests17(String name) {
@@ -36,9 +36,9 @@ public class CompletionTests17 extends AbstractJavaModelCompletionTests {
 
 	public void setUpSuite() throws Exception {
 		if (COMPLETION_PROJECT == null) {
-			COMPLETION_PROJECT = setUpJavaProject("Completion", "17");
+			COMPLETION_PROJECT = setUpJavaProject("Completion", "21");
 		} else {
-			setUpProjectCompliance(COMPLETION_PROJECT, "17");
+			setUpProjectCompliance(COMPLETION_PROJECT, "21");
 		}
 		super.setUpSuite();
 		COMPLETION_PROJECT.setOption(JavaCore.COMPILER_PB_ENABLE_PREVIEW_FEATURES, JavaCore.DISABLED);
@@ -706,38 +706,69 @@ public class CompletionTests17 extends AbstractJavaModelCompletionTests {
 
 	}
 
-	public void testGH2256() throws JavaModelException {
+	public void testGH2260_CaseTypePattern_NonRecord() throws JavaModelException {
 		this.workingCopies = new ICompilationUnit[1];
-		this.workingCopies[0] = getWorkingCopy("/Completion/src/EnumClass.java", """
-				public enum EnumClass  {
-
+		this.workingCopies[0] = getWorkingCopy("/Completion/src/SwitchTypePattern.java", """
+				public class SwitchTypePattern  {
+					public class Shape {}
+					public class Circle extends Shape {}
+
+					public foo(Shape s) {
+						switch(s) {
+							case Circ
+						}
+					}
 				}\
 				""");
 		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
 		requestor.allowAllRequiredProposals();
 		String str = this.workingCopies[0].getSource();
-		String completeBehind = "EnumClass ";
+		String completeBehind = "case Circ";
 		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 		assertResults("""
-				implements[KEYWORD]{implements, null, null, implements, null, 49}\
+			SwitchTypePattern.Circle[TYPE_REF]{Circle, , LSwitchTypePattern$Circle;, null, null, 72}\
 					""", requestor.getResults());
 	}
 
-	public void testGH2261() throws JavaModelException {
-		this.workingCopies = new ICompilationUnit[1];
-		this.workingCopies[0] = getWorkingCopy("/Completion/src/SealedI.java", """
-				public sealed interface SealedI p  {
+	public void testGH2260_CaseTypePattern_Destructor() throws JavaModelException {
+		this.workingCopies = new ICompilationUnit[3];
+		this.workingCopies[0] = getWorkingCopy("/Completion/src/Shape.java", """
+				public interface Shape  {
+					public record Circle1(String name, int radius) implements Shape  {
+					}
+	
+				}\
+				""");
+		this.workingCopies[1] = getWorkingCopy("/Completion/src/Circle.java", """
+				public record Circle(String name, int radius) implements Shape  {
+				}\
+				""");
+	
+		this.workingCopies[2] = getWorkingCopy("/Completion/src/SwitchTypePattern.java", """
+				public class SwitchTypePattern  {
+					public record Circle2(String name, int radius) implements Shape  {
+					}
+					public foo(Shape s) {
+						switch(s) {
+							case Circle
+						}
+					}
 				}\
 				""");
 		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
 		requestor.allowAllRequiredProposals();
-		String str = this.workingCopies[0].getSource();
-		String completeBehind = "SealedI p";
+		String str = this.workingCopies[2].getSource();
+		String completeBehind = "case Circle";
 		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
-		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+		this.workingCopies[2].codeComplete(cursorLocation, requestor, this.wcOwner);
 		assertResults("""
-				permits[RESTRICTED_IDENTIFIER]{permits, null, null, permits, null, 49}\
+			[TYPE_PATTERN]{Circle(var name,var radius), LCircle;, null, null, null, 20}
+			[TYPE_PATTERN]{Circle1(var name,var radius), LShape$Circle1;, null, null, null, 20}
+			[TYPE_PATTERN]{Circle2(var name,var radius), LSwitchTypePattern$Circle2;, null, null, null, 20}
+			Shape.Circle1[TYPE_REF]{Shape.Circle1, , LShape$Circle1;, null, null, 49}
+			Circle[TYPE_REF]{Circle, , LCircle;, null, null, 56}
+			SwitchTypePattern.Circle2[TYPE_REF]{Circle2, , LSwitchTypePattern$Circle2;, null, null, 72}\
 					""", requestor.getResults());
-	}
+	}	
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
index 4fbb8fb335..04ec93a371 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
@@ -454,6 +454,9 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 			case CompletionProposal.LAMBDA_EXPRESSION :
 				buffer.append("LAMBDA_EXPRESSION"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.TYPE_PATTERN :
+				buffer.append("TYPE_PATTERN"); //$NON-NLS-1$
+				break;
 			default :
 				buffer.append("PROPOSAL"); //$NON-NLS-1$
 				break;
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index e322e384a1..ba7510bb8d 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -205,6 +205,7 @@ import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.ISourceType;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
+import org.eclipse.jdt.internal.compiler.impl.JavaFeature;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
@@ -228,6 +229,7 @@ import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.RecordComponentBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
@@ -696,6 +698,7 @@ public final class CompletionEngine
 
 	private final static char[] JAVA_LANG_OBJECT_SIGNATURE =
 		createTypeSignature(CharOperation.concatWith(JAVA_LANG, '.'), OBJECT);
+	private final static char[] JAVA_LANG_STRING_SIGNATURE = CharOperation.concatWith(JAVA_LANG_STRING, '.');
 	private final static char[] JAVA_LANG_NAME =
 		CharOperation.concatWith(JAVA_LANG, '.');
 	private final static char[] GET = "get".toCharArray(); //$NON-NLS-1$
@@ -2017,7 +2020,11 @@ public final class CompletionEngine
 		} else if (astNode instanceof CompletionOnMethodReturnType) {
 			completionOnMethodReturnType(astNode, scope);
 		} else if (astNode instanceof CompletionOnSingleNameReference) {
-			completionOnSingleNameReference(astNode, astNodeParent, scope, insideTypeAnnotation);
+			if(astNodeParent instanceof SwitchStatement ss && ss.caseCount > 0) {
+				completionAtSwitchCase(astNode, ss, scope);
+			} else {
+				completionOnSingleNameReference(astNode, astNodeParent, scope, insideTypeAnnotation);
+			}
 		} else if (astNode instanceof CompletionOnProvidesInterfacesQualifiedTypeReference) {
 			completionOnProvidesInterfacesQualifiedTypeReference(astNode, astNodeParent, qualifiedBinding, scope);
 		} else if (astNode instanceof CompletionOnProvidesInterfacesSingleTypeReference) {
@@ -2027,7 +2034,11 @@ public final class CompletionEngine
 		} else if (astNode instanceof CompletionOnProvidesImplementationsSingleTypeReference) {
 			completionOnProvidesImplementationsSingleTypeReference(astNode, astNodeParent, qualifiedBinding, scope);
 		} else if (astNode instanceof CompletionOnSingleTypeReference) {
-			completionOnSingleTypeReference(astNode, astNodeParent, qualifiedBinding, scope);
+			if(astNodeParent instanceof InstanceOfExpression ioe) {
+				completionAtInstanceOf(astNodeParent, ioe, qualifiedBinding, scope);
+			} else {
+				completionOnSingleTypeReference(astNode, astNodeParent, qualifiedBinding, scope);
+			}
 		} else if (astNode instanceof CompletionOnQualifiedNameReference) {
 			completionOnQualifiedNameReference(astNode, enclosingNode, qualifiedBinding, scope, insideTypeAnnotation);
 		} else if (astNode instanceof CompletionOnQualifiedTypeReference) {
@@ -3963,6 +3974,7 @@ public final class CompletionEngine
 				}
 			}
 			else {
+					findTypesAndPackages(this.completionToken, scope, true, false, new ObjectVector());
 					// if switch with class/interface/record - J17 onwards
 					char[][] keywords = new char[2][];
 					int count = 0;
@@ -11252,7 +11264,7 @@ public final class CompletionEngine
 									if (TypeBinding.equalsEquals(localType, otherType))
 										continue next;
 								}
-
+								
 								if (this.assistNodeIsExtendedType && localType.isFinal()) continue next;
 								if (this.assistNodeIsInterfaceExcludingAnnotation && localType.isAnnotationType()) continue next;
 								if(this.assistNodeIsClass) {
@@ -14773,4 +14785,112 @@ public final class CompletionEngine
 		}
 	}
 
+	private void completionAtSwitchCase(ASTNode astNode, SwitchStatement switchStatement, Scope scope) {
+		final CompletionOnSingleNameReference singleNameReference = (CompletionOnSingleNameReference) astNode;
+
+		this.completionToken = singleNameReference.token;
+		if(switchStatement.expression.resolvedType != null) {
+			TypeBinding exprType = switchStatement.expression.resolvedType;
+			// handle completions of enum literals
+			if(exprType.isEnum()) {
+				if (!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
+					this.assistNodeIsEnum = true;
+					findEnumConstantsFromSwithStatement(this.completionToken, switchStatement);
+				}
+			} else if (exprType.isClass() || exprType.isInterface() || exprType.isRecord()) {
+				// suggest type reference completions for now if its java 21 and above or it is a string
+				
+				// We can later suggest more smart completions such as
+				// - completion for Subtypes
+				// - completion for subtypes with variable name, <<TypeName varName>>
+				// - completions for extracing record components a.k.a Record desctructions
+				
+				final boolean isPatternMatchingSupported = JavaFeature.PATTERN_MATCHING_IN_SWITCH.isSupported(this.compilerOptions);
+				final boolean isJavaLangString = CharOperation.equals(JAVA_LANG_STRING_SIGNATURE, exprType.signableName());
+				final boolean isApplicableForPatternMatching = isPatternMatchingSupported && (!isJavaLangString && (exprType.isInterface() || exprType.isClass()));
+				if (isApplicableForPatternMatching
+						|| CharOperation.equals(JAVA_LANG_STRING_SIGNATURE, exprType.signableName())) {
+					findTypesAndPackages(this.completionToken, scope.enclosingMethodScope(), true, false,
+							new ObjectVector());
+				}
+
+				if (isApplicableForPatternMatching) {
+					for (char[] fqn : this.knownTypes.keyTable) {
+						checkCancel();
+						if (fqn == null)
+							continue;
+						char[][] simpleNames = Signature.getSimpleNames(fqn);
+
+						ReferenceBinding binding = (ReferenceBinding) scope.getType(simpleNames, simpleNames.length);
+						if (binding != null && binding.isRecord()) {
+							computeDestructors(binding);
+						}
+					}
+				}
+			} else {
+				// fallback to old behavior for primitives
+				completionOnSingleNameReference(astNode, switchStatement, scope, false);
+			}
+		}
+	}
+
+	private void computeDestructors(ReferenceBinding recordType) {
+		if (this.requestor.isIgnored(CompletionProposal.TYPE_PATTERN)) {
+			return;
+		}
+		checkCancel();
+
+		char[] typeCompletion = CharOperation.concat(recordType.qualifiedPackageName(),
+				recordType.qualifiedSourceName(), '.');
+		char[] packageName = recordType.isLocalType() ? null : recordType.qualifiedPackageName();
+		char[] typeName = recordType.qualifiedSourceName();
+
+		int componentsLength = recordType.components().length;
+		StringBuilder builder = new StringBuilder(String.valueOf(recordType.sourceName()));
+		builder.append("("); //$NON-NLS-1$
+		for (int i = 0; i < componentsLength; i++) {
+			RecordComponentBinding comp = recordType.components()[i];
+			builder.append(VAR).append(' ').append(comp.readableName());
+			if (i < (componentsLength - 1)) {
+				builder.append(',');
+			}
+		}
+		builder.append(')');
+
+		char[] completion = builder.toString().toCharArray();
+		int relevance = computeRelevanceForConstructor();
+		relevance += computeRelevanceForExpectingType(recordType);
+
+		InternalCompletionProposal typeProposal = createProposal(CompletionProposal.TYPE_REF,
+				this.actualCompletionPosition);
+		typeProposal.nameLookup = this.nameEnvironment.nameLookup;
+		typeProposal.completionEngine = this;
+		typeProposal.setDeclarationSignature(packageName);
+		typeProposal.setSignature(getRequiredTypeSignature(recordType));
+		typeProposal.setPackageName(packageName);
+		typeProposal.setTypeName(typeName);
+		typeProposal.setCompletion(typeCompletion);
+		typeProposal.setFlags(recordType.modifiers);
+		typeProposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+		typeProposal.setTokenRange(this.startPosition - this.offset, this.endPosition - this.offset);
+		typeProposal.setRelevance(relevance);
+
+		InternalCompletionProposal proposal = createProposal(CompletionProposal.TYPE_PATTERN,
+				this.actualCompletionPosition);
+		proposal.setCompletion(completion);
+		proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+		proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+		proposal.setRequiredProposals(new CompletionProposal[] { typeProposal });
+		proposal.setRelevance(relevance);
+		proposal.setDeclarationSignature(getSignature(recordType));
+
+		this.requestor.accept(proposal);
+	}
+
+	private void completionAtInstanceOf(ASTNode astNode, InstanceOfExpression ioExpr, Binding qualifiedBinding,
+			Scope scope) {
+		// use same behavior for now
+		completionOnSingleTypeReference(astNode, ioExpr, qualifiedBinding, scope);
+	}
+
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionProposal.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionProposal.java
index 51c69b3b13..8bee8315ab 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionProposal.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionProposal.java
@@ -1161,6 +1161,9 @@ public class InternalCompletionProposal extends CompletionProposal {
 			case CompletionProposal.LAMBDA_EXPRESSION :
 				buffer.append("LAMBDA_EXPRESSION"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.TYPE_PATTERN:
+				buffer.append("TYPE_PATTERN"); //$NON-NLS-1$
+				break;
 			default :
 				buffer.append("PROPOSAL"); //$NON-NLS-1$
 				break;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
index 28c1497777..fa6c44d607 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
@@ -886,6 +886,20 @@ public class CompletionProposal {
 	 */
 	public static final int LAMBDA_EXPRESSION = 30;
 
+	/**
+	 * Completion is a type pattern expression.
+	 * This kind of completion might occur in a context like
+	 * <code>"if instanceof ^"</code> and complete it to
+	 * <code>"if instanceof List list"</code> or
+	 * <code>"case ^"</code> and complete it to
+	 * <code>"case List list"</code> or
+	 * <code>"case ^"</code> and complete it to
+	 * <code>"case List list"</code>
+	 * @see #getKind()
+	 * @since 3.28
+	 */
+	public static final int TYPE_PATTERN = 31;
+
 	/**
 	 * First valid completion kind.
 	 *
@@ -898,7 +912,7 @@ public class CompletionProposal {
 	 *
 	 * @since 3.1
 	 */
-	protected static final int LAST_KIND = LAMBDA_EXPRESSION;
+	protected static final int LAST_KIND = TYPE_PATTERN;
 
 	/**
 	 * Creates a basic completion proposal. All instance
